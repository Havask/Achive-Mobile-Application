{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nexport var wait = function wait(ms) {\n  return new Promise(function (resolve) {\n    return setTimeout(resolve, ms);\n  });\n};\nexport var extractUrlFromString = function extractUrlFromString(string) {\n  var regex = /(https?:\\/\\/(?:www\\.|(?!www))[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\\.[^\\s]{2,}|www\\.[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\\.[^\\s]{2,}|https?:\\/\\/(?:www\\.|(?!www))[a-zA-Z0-9]+\\.[^\\s]{2,}|www\\.[a-zA-Z0-9]+\\.[^\\s]{2,})/gm;\n  var match = string.match(regex);\n\n  if (match && match.length > 0) {\n    return match[0];\n  }\n\n  return null;\n};\nexport var fetchMetaData = function fetchMetaData(url) {\n  var response, text, ogImage, ogTitle, ogDescription, image, title, description;\n  return _regeneratorRuntime.async(function fetchMetaData$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          _context.next = 2;\n          return _regeneratorRuntime.awrap(fetch(url));\n\n        case 2:\n          response = _context.sent;\n          _context.next = 5;\n          return _regeneratorRuntime.awrap(response.text());\n\n        case 5:\n          text = _context.sent;\n          ogImage = new RegExp('<meta.*property=\"og:image\".*content=\"(.*)\".*/>');\n          ogTitle = new RegExp('<meta.*property=\"og:title\".*content=\"(.*)\".*/>');\n          ogDescription = new RegExp('<meta.*property=\"og:description\".*content=\"(.*)\".*/>');\n          image = text.match(ogImage);\n          title = text.match(ogTitle);\n          description = text.match(ogDescription);\n\n          if (!(image && title && description)) {\n            _context.next = 14;\n            break;\n          }\n\n          return _context.abrupt(\"return\", {\n            image: image[1],\n            title: title[1],\n            description: description[1],\n            url: url\n          });\n\n        case 14:\n          return _context.abrupt(\"return\", null);\n\n        case 15:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n};","map":{"version":3,"sources":["helpers.ts"],"names":["wait","ms","resolve","setTimeout","extractUrlFromString","string","regex","match","fetchMetaData","response","fetch","text","ogImage","ogTitle","ogDescription","image","title","description","url"],"mappings":";AAMA,OAAO,IAAMA,IAAI,GAAIC,SAARD,IAAQC,CAAAA,EAAD;AAAA,SAClB,IAAA,OAAA,CAAaC,UAAAA,OAAD;AAAA,WAAaC,UAAU,CAAA,OAAA,EAD9B,EAC8B,CAAvB;AAAA,GAAZ,CADkB;AAAA,CAAb;AAQP,OAAO,IAAMC,oBAAoB,GAAIC,SAAxBD,oBAAwBC,CAAAA,MAAD,EAAmC;AACrE,MAAMC,KAAK,GAAX,qNAAA;AAEA,MAAMC,KAAK,GAAGF,MAAM,CAANA,KAAAA,CAAd,KAAcA,CAAd;;AAEA,MAAIE,KAAK,IAAIA,KAAK,CAALA,MAAAA,GAAb,CAAA,EAA+B;AAC7B,WAAOA,KAAK,CAAZ,CAAY,CAAZ;AACD;;AAED,SAAA,IAAA;AATK,CAAA;AAoBP,OAAO,IAAMC,aAAa,GAAG,SAAhBA,aAAgB,CAAA,GAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,2CAGJE,KAAK,CAA5B,GAA4B,CAHD;;AAAA;AAGrBD,UAAAA,QAHqB;AAAA;AAAA,2CAIRA,QAAQ,CAA3B,IAAmBA,EAJQ;;AAAA;AAIrBE,UAAAA,IAJqB;AAMrBC,UAAAA,OANqB,GAMX,IAAA,MAAA,CAAhB,gDAAgB,CANW;AAOrBC,UAAAA,OAPqB,GAOX,IAAA,MAAA,CAAhB,gDAAgB,CAPW;AAQrBC,UAAAA,aARqB,GAQL,IAAA,MAAA,CAAtB,sDAAsB,CARK;AAYrBC,UAAAA,KAZqB,GAYbJ,IAAI,CAAJA,KAAAA,CAAd,OAAcA,CAZa;AAarBK,UAAAA,KAbqB,GAabL,IAAI,CAAJA,KAAAA,CAAd,OAAcA,CAba;AAcrBM,UAAAA,WAdqB,GAcPN,IAAI,CAAJA,KAAAA,CAApB,aAAoBA,CAdO;;AAAA,gBAgBvBI,KAAK,IAALA,KAAAA,IAAJ,WAhB2B;AAAA;AAAA;AAAA;;AAAA,2CAiBlB;AACLA,YAAAA,KAAK,EAAEA,KAAK,CADP,CACO,CADP;AAELC,YAAAA,KAAK,EAAEA,KAAK,CAFP,CAEO,CAFP;AAGLC,YAAAA,WAAW,EAAEA,WAAW,CAHnB,CAGmB,CAHnB;AAILC,YAAAA,GAAAA,EAAAA;AAJK,WAjBkB;;AAAA;AAAA,2CAyB3B,IAzB2B;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,CAAtB","sourcesContent":["import type { IUrlPreviewBubble } from 'src/types/Chatty.types';\n\n/**\n * `wait` is a function that returns a promise that resolves after a given number of milliseconds\n * @param {number} ms - number\n */\nexport const wait = (ms: number) =>\n  new Promise((resolve) => setTimeout(resolve, ms));\n\n/**\n * It takes a string and returns the first URL found in the string\n * @param {string} string - The string to extract the URL from.\n * @returns The first match of the regex.\n */\nexport const extractUrlFromString = (string: string): string | null => {\n  const regex =\n    /(https?:\\/\\/(?:www\\.|(?!www))[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\\.[^\\s]{2,}|www\\.[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\\.[^\\s]{2,}|https?:\\/\\/(?:www\\.|(?!www))[a-zA-Z0-9]+\\.[^\\s]{2,}|www\\.[a-zA-Z0-9]+\\.[^\\s]{2,})/gm;\n  const match = string.match(regex);\n\n  if (match && match.length > 0) {\n    return match[0];\n  }\n\n  return null;\n};\n\n/**\n * It takes a URL, fetches the HTML from that URL, and then parses the HTML for the og:image, og:title,\n * and og:description meta tags. If all three of these meta tags are found, it returns a\n * UrlPreviewBubble object with the image, title, and description. If any of these meta tags are\n * missing, it returns null\n * @param {string} url - The URL of the page to fetch.\n * @returns An object with the following properties:\n */\nexport const fetchMetaData = async (\n  url: string\n): Promise<IUrlPreviewBubble | null> => {\n  const response = await fetch(url);\n  const text = await response.text();\n\n  const ogImage = new RegExp('<meta.*property=\"og:image\".*content=\"(.*)\".*/>');\n  const ogTitle = new RegExp('<meta.*property=\"og:title\".*content=\"(.*)\".*/>');\n  const ogDescription = new RegExp(\n    '<meta.*property=\"og:description\".*content=\"(.*)\".*/>'\n  );\n\n  const image = text.match(ogImage);\n  const title = text.match(ogTitle);\n  const description = text.match(ogDescription);\n\n  if (image && title && description) {\n    return {\n      image: image[1],\n      title: title[1],\n      description: description[1],\n      url,\n    };\n  }\n\n  return null;\n};\n"]},"metadata":{},"sourceType":"module"}