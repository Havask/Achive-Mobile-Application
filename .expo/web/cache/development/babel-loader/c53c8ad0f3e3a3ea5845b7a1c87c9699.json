{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nexport var wait = function wait(ms) {\n  return new Promise(function (resolve) {\n    return setTimeout(resolve, ms);\n  });\n};\nexport var extractUrlFromString = function extractUrlFromString(string) {\n  var regex = /(https?:\\/\\/(?:www\\.|(?!www))[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\\.[^\\s]{2,}|www\\.[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\\.[^\\s]{2,}|https?:\\/\\/(?:www\\.|(?!www))[a-zA-Z0-9]+\\.[^\\s]{2,}|www\\.[a-zA-Z0-9]+\\.[^\\s]{2,})/gm;\n  var match = string.match(regex);\n\n  if (match && match.length > 0) {\n    return match[0];\n  }\n\n  return null;\n};\nexport var fetchMetaData = function fetchMetaData(url) {\n  var response, text, ogImage, ogTitle, ogDescription, image, title, description;\n  return _regeneratorRuntime.async(function fetchMetaData$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          _context.next = 2;\n          return _regeneratorRuntime.awrap(fetch(url));\n\n        case 2:\n          response = _context.sent;\n          _context.next = 5;\n          return _regeneratorRuntime.awrap(response.text());\n\n        case 5:\n          text = _context.sent;\n          ogImage = new RegExp('<meta.*property=\"og:image\".*content=\"(.*)\".*/>');\n          ogTitle = new RegExp('<meta.*property=\"og:title\".*content=\"(.*)\".*/>');\n          ogDescription = new RegExp('<meta.*property=\"og:description\".*content=\"(.*)\".*/>');\n          image = text.match(ogImage);\n          title = text.match(ogTitle);\n          description = text.match(ogDescription);\n\n          if (!(image && title && description)) {\n            _context.next = 14;\n            break;\n          }\n\n          return _context.abrupt(\"return\", {\n            image: image[1],\n            title: title[1],\n            description: description[1],\n            url: url\n          });\n\n        case 14:\n          return _context.abrupt(\"return\", null);\n\n        case 15:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n};","map":{"version":3,"mappings":";AAMA,OAAO,IAAMA,IAAI,GAAIC,SAARD,IAAQC,GAAD;EAAA,OAClB,IAAIC,OAAJ,CAAaC,iBAAD;IAAA,OAAaC,UAAU,CAACD,OAAD,EAAUF,EAAV,CAAvB;EAAA,CAAZ,CADkB;AAAA,CAAb;AAQP,OAAO,IAAMI,oBAAoB,GAAIC,SAAxBD,oBAAwBC,OAAD,EAAmC;EACrE,IAAMC,KAAK,GACT,qNADF;EAEA,IAAMC,KAAK,GAAGF,MAAM,CAACE,KAAPF,CAAaC,KAAbD,CAAd;;EAEA,IAAIE,KAAK,IAAIA,KAAK,CAACC,MAAND,GAAe,CAA5B,EAA+B;IAC7B,OAAOA,KAAK,CAAC,CAAD,CAAZ;EACD;;EAED,OAAO,IAAP;AATK;AAoBP,OAAO,IAAME,aAAa,GAAG,SAAhBA,aAAgB,CAC3BC,GAD2B;EAAA;EAAA;IAAA;MAAA;QAAA;UAAA;UAAA,iCAGJC,KAAK,CAACD,GAAD,CAHD;;QAAA;UAGrBE,QAHqB;UAAA;UAAA,iCAIRA,QAAQ,CAACC,IAATD,EAJQ;;QAAA;UAIrBC,IAJqB;UAMrBC,OANqB,GAMX,IAAIC,MAAJ,CAAW,gDAAX,CANW;UAOrBC,OAPqB,GAOX,IAAID,MAAJ,CAAW,gDAAX,CAPW;UAQrBE,aARqB,GAQL,IAAIF,MAAJ,CACpB,sDADoB,CARK;UAYrBG,KAZqB,GAYbL,IAAI,CAACN,KAALM,CAAWC,OAAXD,CAZa;UAarBM,KAbqB,GAabN,IAAI,CAACN,KAALM,CAAWG,OAAXH,CAba;UAcrBO,WAdqB,GAcPP,IAAI,CAACN,KAALM,CAAWI,aAAXJ,CAdO;;UAAA,MAgBvBK,KAAK,IAAIC,KAATD,IAAkBE,WAhBK;YAAA;YAAA;UAAA;;UAAA,iCAiBlB;YACLF,KAAK,EAAEA,KAAK,CAAC,CAAD,CADP;YAELC,KAAK,EAAEA,KAAK,CAAC,CAAD,CAFP;YAGLC,WAAW,EAAEA,WAAW,CAAC,CAAD,CAHnB;YAILV;UAJK,CAjBkB;;QAAA;UAAA,iCAyBpB,IAzBoB;;QAAA;QAAA;UAAA;MAAA;IAAA;EAAA;AAAA,CAAtB","names":["wait","ms","Promise","resolve","setTimeout","extractUrlFromString","string","regex","match","length","fetchMetaData","url","fetch","response","text","ogImage","RegExp","ogTitle","ogDescription","image","title","description"],"sources":["helpers.ts"],"sourcesContent":["import type { IUrlPreviewBubble } from 'src/types/Chatty.types';\n\n/**\n * `wait` is a function that returns a promise that resolves after a given number of milliseconds\n * @param {number} ms - number\n */\nexport const wait = (ms: number) =>\n  new Promise((resolve) => setTimeout(resolve, ms));\n\n/**\n * It takes a string and returns the first URL found in the string\n * @param {string} string - The string to extract the URL from.\n * @returns The first match of the regex.\n */\nexport const extractUrlFromString = (string: string): string | null => {\n  const regex =\n    /(https?:\\/\\/(?:www\\.|(?!www))[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\\.[^\\s]{2,}|www\\.[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\\.[^\\s]{2,}|https?:\\/\\/(?:www\\.|(?!www))[a-zA-Z0-9]+\\.[^\\s]{2,}|www\\.[a-zA-Z0-9]+\\.[^\\s]{2,})/gm;\n  const match = string.match(regex);\n\n  if (match && match.length > 0) {\n    return match[0];\n  }\n\n  return null;\n};\n\n/**\n * It takes a URL, fetches the HTML from that URL, and then parses the HTML for the og:image, og:title,\n * and og:description meta tags. If all three of these meta tags are found, it returns a\n * UrlPreviewBubble object with the image, title, and description. If any of these meta tags are\n * missing, it returns null\n * @param {string} url - The URL of the page to fetch.\n * @returns An object with the following properties:\n */\nexport const fetchMetaData = async (\n  url: string\n): Promise<IUrlPreviewBubble | null> => {\n  const response = await fetch(url);\n  const text = await response.text();\n\n  const ogImage = new RegExp('<meta.*property=\"og:image\".*content=\"(.*)\".*/>');\n  const ogTitle = new RegExp('<meta.*property=\"og:title\".*content=\"(.*)\".*/>');\n  const ogDescription = new RegExp(\n    '<meta.*property=\"og:description\".*content=\"(.*)\".*/>'\n  );\n\n  const image = text.match(ogImage);\n  const title = text.match(ogTitle);\n  const description = text.match(ogDescription);\n\n  if (image && title && description) {\n    return {\n      image: image[1],\n      title: title[1],\n      description: description[1],\n      url,\n    };\n  }\n\n  return null;\n};\n"]},"metadata":{},"sourceType":"module"}